# javascript 垃圾回收机制

### 1. 自动垃圾回收机制，管理内存

`优点：`

- 简化了开发量，不需要继续申请内存、释放内存；

`缺点：`

- 无法完全掌控内存，不能申请、分配

# node 内存管理

### 服务器端有必要管理内存

- 内存泄漏后果严重，可能引起文件描述符耗尽、链接占满

### nodejs 中的 js 对象都是通过 V8 分配内存的

# V8 引擎内存

### 1. 内存限制

`原因：因为 1.5 G 的内存，收集起来需要 1 秒以上，这 1 秒称之为 stop the world，应用的性能和响应能力都会下降`

> 缺点：无法操作大对象

- 64 位：1.4G
- 32 位：0.7G

### 2. 打开限制

> 缺点：一旦初始化成功，生效不能再修改

```cmd
node --max-old-space-size=2000 app.js //单位为 M
node --max-new-space-size=1024 app.js // 单位为 kb
```

### 3. V8 引擎的垃圾回收机制

**`分代`**

> 按照存活的时间划分，越小越新

- 新生代

  - 默认大小

    - 64 位 默认大小 32M
    - 32 位 默认大小 16M

  - 分区

    - from 区域
    - to 区域

  - 回收算法：`scavenge 算法`

    - > 优点：速度快，效率高
    - > 缺点：浪费空间（但是，介于存活对象少，空间原本就小 ，所以这种方式最适合）

    1. 检查 from 区域是否有存活的对象；

       - `怎么区分？`\
         从根对象（window）出发，根据引用关系一路寻找，能够达到的对象即为存活的对象
         > `通过给对象赋值 null，断开链接，回收内存`

       - `怎么存储？`\
         根据 scan 指针指定对象依次拷贝到 to 区域，分配指针后移一位。

       - `什么时候停止？`\
         直至 scan 指针和分配指针重合

    2. 将它们拷贝到 to 区域中；
    3. 格式化 from 区域；
    4. from 和 to 位置对掉。

  - 升级：`移动到老生代`
    - 经过 5 次以上的回收
    - to 的内存使用占比超过 25% 的最大限制
    - 超大对象

- 老生代：

  - 默认大小

    - 64 位 默认大小 1400M
    - 32 位 默认大小 700M

  - 回收算法：

    - `标记清除 mark-sweep`：标记存活的对象（`因为在老生代中，存活的对象相对少，所以标记存活的`），区分死亡与存活的对象，便于后面进行标记整理

    - `标记整理 mark-compact`：向左移动：存活居左，死亡居右，回收右边所有区域（包括空白区域）

      > 由于移动对象耗时，所以只有当内存不足以对新生代升级过来时，才会触发 mark-compact

    - `增量标记 incremental-marking`：每移动一次，暂停一下，执行程序，然后再移动一次暂停一次，回收机制和程序运行是交替进行的，致使停顿时间减少到 1/6（将整体大暂停，改成多个小暂停）

      > 由于回收时需要暂停程序运行，在老生代中，数据量大，空间大，可能会导致 stop the world，所以产生这个对应的优化方案
